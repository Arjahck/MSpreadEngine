"""
Unified malware implementation.

This module defines the core malware behavior with configurable parameters
for creating various malware types (worm, virus, ransomware, etc.).
"""

from typing import List, Dict, Optional, Set, Any
from enum import Enum
import random


class MalwareType(Enum):
    WORM = "worm"
    VIRUS = "virus"
    RANSOMWARE = "ransomware"
    TROJAN = "trojan"
    CUSTOM = "custom"


class Malware:
    """Configurable malware class for all malware types."""

    def __init__(
        self,
        malware_id: str,
        malware_type: MalwareType = MalwareType.CUSTOM,
        infection_rate: float = 0.5,
        latency: int = 1,
        spread_pattern: str = "random",
        target_os: Optional[List[str]] = None,
        target_node_types: Optional[List[str]] = None,
        avoids_admin: bool = True,
        requires_interaction: bool = False,
        network=None,
        **attributes
    ):
        """
        Initialize configurable malware.

        Args:
            malware_id: Unique identifier for the malware instance
            malware_type: Type of malware (for categorization)
            infection_rate: Probability of infection per connection (0-1), default 0.5
            latency: Time steps before infection spreads
            spread_pattern: "random" (probabilistic subset), "bfs" (aggressive), "dfs" (stealthy/single)
            target_os: List of target OS strings (e.g., ["Windows", "Linux"]). None = All.
            target_node_types: List of target node types. None = All.
            avoids_admin: If True, cannot infect admin devices from non-admin devices
            requires_interaction: If True, reduces effective infection rate (simulating user click need)
            network: NetworkGraph instance (used for checking device attributes)
            **attributes: Additional malware-specific attributes
        """
        self.malware_id = malware_id
        self.malware_type = malware_type
        self.infection_rate = infection_rate
        self.latency = latency
        self.spread_pattern = spread_pattern.lower()
        self.target_os = [os.lower() for os in target_os] if target_os else None
        self.target_node_types = [nt.lower() for nt in target_node_types] if target_node_types else None
        self.avoids_admin = avoids_admin
        self.requires_interaction = requires_interaction
        
        self.network = network
        self.infected_devices: Set[str] = set()
        self.attributes = attributes

    def spread(self, infected_device: str, neighbors: List[str]) -> List[str]:
        """
        Determine which neighbors get infected based on configuration.

        Args:
            infected_device: ID of the infected device
            neighbors: List of neighboring device IDs

        Returns:
            List of newly infected device IDs
        """
        newly_infected = []
        
        # 1. Calculate Effective Infection Rate
        effective_rate = self.infection_rate
        if self.requires_interaction:
            effective_rate *= 0.6  # Reduce rate if interaction needed
        
        # 2. Get Source Attributes
        source_attrs = {}
        source_admin = True # Default assumption
        
        if self.network:
            try:
                source_attrs = self.network.get_device_attributes(infected_device)
                source_admin = source_attrs.get('admin_user', True)
            except:
                pass
        
        # 3. Filter Neighbors
        candidates = []
        for neighbor in neighbors:
            if neighbor in self.infected_devices:
                continue
                
            # Get Neighbor Attributes
            neighbor_attrs = {}
            if self.network:
                try:
                    neighbor_attrs = self.network.get_device_attributes(neighbor)
                except:
                    pass
            
            # Check Admin Constraint
            if self.avoids_admin and not source_admin:
                neighbor_admin = neighbor_attrs.get('admin_user', True)
                if neighbor_admin:
                    continue  # Blocked: Non-admin source cannot infect Admin target

            # Check OS Constraint
            if self.target_os:
                neighbor_os = str(neighbor_attrs.get('os', '')).lower()
                # Check if any target OS is substring of neighbor OS
                if not any(t in neighbor_os for t in self.target_os):
                     continue # Blocked: Wrong OS

            # Check Node Type Constraint
            if self.target_node_types:
                neighbor_type = str(neighbor_attrs.get('device_type', '')).lower()
                if neighbor_type not in self.target_node_types:
                    continue # Blocked: Wrong Node Type

            candidates.append(neighbor)

        # 4. Apply Spreading Pattern
        if self.spread_pattern == "bfs":
            # BFS = Try to infect ALL candidates (aggressive)
            for candidate in candidates:
                if random.random() < effective_rate:
                    newly_infected.append(candidate)
                    
        elif self.spread_pattern == "dfs":
             # DFS-like = Infect ONE candidate max (stealthy/linear)
             if candidates:
                 # Pick one random candidate to try
                 target = random.choice(candidates)
                 if random.random() < effective_rate:
                     newly_infected.append(target)
                     
        else: # "random" (Default)
            # Standard probabilistic spread
            for candidate in candidates:
                if random.random() < effective_rate:
                    newly_infected.append(candidate)

        return newly_infected

    def get_behavior(self) -> Dict:
        """
        Get malware behavior characteristics.

        Returns:
            Dictionary describing malware behavior
        """
        return {
            "type": self.malware_type.value if isinstance(self.malware_type, Enum) else str(self.malware_type),
            "infection_rate": self.infection_rate,
            "spread_pattern": self.spread_pattern,
            "avoids_admin": self.avoids_admin,
            "requires_interaction": self.requires_interaction,
            "target_os": self.target_os if self.target_os else "all",
            "target_node_types": self.target_node_types if self.target_node_types else "all"
        }

    def mark_infected(self, device_id: str) -> None:
        """
        Mark a device as infected.

        Args:
            device_id: Device ID
        """
        self.infected_devices.add(device_id)

    def get_infected_count(self) -> int:
        """
        Get the number of infected devices.

        Returns:
            Count of infected devices
        """
        return len(self.infected_devices)
