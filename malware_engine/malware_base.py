"""
Unified malware implementation.

This module defines the core malware behavior with configurable parameters
for creating various malware types (worm, virus, ransomware, etc.).
"""

from typing import List, Dict, Optional, Set, Any
from enum import Enum
import random


class MalwareType(Enum):
    WORM = "worm"
    VIRUS = "virus"
    RANSOMWARE = "ransomware"
    TROJAN = "trojan"
    CUSTOM = "custom"


class Malware:
    """Configurable malware class for all malware types."""

    def __init__(
        self,
        malware_id: str,
        malware_type: MalwareType = MalwareType.CUSTOM,
        infection_rate: float = 0.5,
        latency: int = 1,
        spread_pattern: str = "random",
        target_os: Optional[List[str]] = None,
        target_node_types: Optional[List[str]] = None,
        avoids_admin: bool = True,
        requires_interaction: bool = False,
        network=None,
        **attributes
    ):
        """
        Initialize configurable malware.

        Args:
            malware_id: Unique identifier for the malware instance
            malware_type: Type of malware (for categorization)
            infection_rate: Probability of infection per connection (0-1), default 0.5
            latency: Time steps before infection spreads
            spread_pattern: "random" (probabilistic subset), "bfs" (aggressive), "dfs" (stealthy/single)
            target_os: List of target OS strings (e.g., ["Windows", "Linux"]). None = All.
            target_node_types: List of target node types. None = All.
            avoids_admin: If True, cannot infect admin devices from non-admin devices
            requires_interaction: If True, reduces effective infection rate (simulating user click need)
            network: NetworkGraph instance (used for checking device attributes)
            **attributes: Additional malware-specific attributes
        """
        self.malware_id = malware_id
        self.malware_type = malware_type
        self.infection_rate = infection_rate
        self.latency = latency
        self.spread_pattern = spread_pattern.lower()
        self.target_os = [os.lower() for os in target_os] if target_os else None
        self.target_node_types = [nt.lower() for nt in target_node_types] if target_node_types else None
        self.avoids_admin = avoids_admin
        self.requires_interaction = requires_interaction
        
        self.network = network
        self.infected_devices: Set[str] = set()
        self.attributes = attributes

    def spread(self, infected_device: str, neighbors: List[str]) -> List[str]:
        """Determine which neighbors get infected based on configuration."""
        newly_infected = []
        
        effective_rate = self.infection_rate
        if self.requires_interaction:
            effective_rate *= 0.6
        
        source_admin = True
        if self.network:
            try:
                source_attrs = self.network.get_device_attributes(infected_device)
                source_admin = source_attrs.get('admin_user', True)
            except:
                pass
        
        candidates = []
        for neighbor in neighbors:
            if neighbor in self.infected_devices:
                continue
                
            neighbor_attrs = {}
            if self.network:
                try:
                    neighbor_attrs = self.network.get_device_attributes(neighbor)
                except:
                    pass
            
            if self.avoids_admin and not source_admin:
                neighbor_admin = neighbor_attrs.get('admin_user', True)
                if neighbor_admin:
                    continue  # Blocked: Non-admin source cannot infect Admin target

            if self.target_os:
                neighbor_os = str(neighbor_attrs.get('os', '')).lower()
                if not any(t in neighbor_os for t in self.target_os):
                     continue # Blocked: Wrong OS

            if self.target_node_types:
                neighbor_type = str(neighbor_attrs.get('device_type', '')).lower()
                if neighbor_type not in self.target_node_types:
                    continue # Blocked: Wrong Node Type

            candidates.append(neighbor)

        if self.spread_pattern == "bfs":
            for candidate in candidates:
                if random.random() < effective_rate:
                    newly_infected.append(candidate)
                    
        elif self.spread_pattern == "dfs":
             if candidates:
                 target = random.choice(candidates)
                 if random.random() < effective_rate:
                     newly_infected.append(target)
                     
        else:
            for candidate in candidates:
                if random.random() < effective_rate:
                    newly_infected.append(candidate)

        return newly_infected

    def get_behavior(self) -> Dict:
        """Get malware behavior characteristics."""
        return {
            "type": self.malware_type.value if isinstance(self.malware_type, Enum) else str(self.malware_type),
            "infection_rate": self.infection_rate,
            "spread_pattern": self.spread_pattern,
            "avoids_admin": self.avoids_admin,
            "requires_interaction": self.requires_interaction,
            "target_os": self.target_os if self.target_os else "all",
            "target_node_types": self.target_node_types if self.target_node_types else "all"
        }

    def mark_infected(self, device_id: str) -> None:
        """Mark a device as infected."""
        self.infected_devices.add(device_id)

    def get_infected_count(self) -> int:
        """Get the number of infected devices."""
        return len(self.infected_devices)
