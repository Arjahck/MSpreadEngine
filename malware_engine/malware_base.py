"""
Base malware class and malware-specific implementations.

This module defines the core malware behavior and specific malware types
(worm, virus, ransomware).
"""

from abc import ABC, abstractmethod
from typing import List, Dict, Optional
from enum import Enum


class MalwareType(Enum):
    WORM = "worm"
    VIRUS = "virus"
    RANSOMWARE = "ransomware"
    TROJAN = "trojan"


class Malware(ABC):
    """Abstract base class for malware types."""

    def __init__(
        self,
        malware_id: str,
        malware_type: MalwareType,
        infection_rate: float = 0.3,
        latency: int = 1,
        network=None,
        **attributes
    ):
        """
        Initialize malware.

        Args:
            malware_id: Unique identifier for the malware instance
            malware_type: Type of malware
            infection_rate: Probability of infection per connection (0-1)
            latency: Time steps before infection spreads
            network: NetworkGraph instance (used for checking device attributes)
            **attributes: Additional malware-specific attributes
        """
        self.malware_id = malware_id
        self.malware_type = malware_type
        self.infection_rate = infection_rate
        self.latency = latency
        self.network = network  # Store reference to network for device attribute checks
        self.infected_devices = set()
        self.attributes = attributes

    @abstractmethod
    def spread(self, infected_device: str, neighbors: List[str]) -> List[str]:
        """
        Determine which neighbors get infected.

        Args:
            infected_device: ID of the infected device
            neighbors: List of neighboring device IDs

        Returns:
            List of newly infected device IDs
        """
        pass

    @abstractmethod
    def get_behavior(self) -> Dict:
        """
        Get malware behavior characteristics.

        Returns:
            Dictionary describing malware behavior
        """
        pass

    def mark_infected(self, device_id: str) -> None:
        """
        Mark a device as infected.

        Args:
            device_id: Device ID
        """
        self.infected_devices.add(device_id)

    def get_infected_count(self) -> int:
        """
        Get the number of infected devices.

        Returns:
            Count of infected devices
        """
        return len(self.infected_devices)


class Worm(Malware):
    """Worm malware implementation."""

    def __init__(self, malware_id: str, **kwargs):
        """Initialize a worm."""
        super().__init__(malware_id, MalwareType.WORM, **kwargs)

    def spread(self, infected_device: str, neighbors: List[str]) -> List[str]:
        """
        Worms spread aggressively to all connected devices.
        
        Respects admin_user device attribute:
        - If infected_device has admin_user=False, can only spread to neighbors with admin_user=False
        - If infected_device has admin_user=True, can spread normally to all neighbors

        Args:
            infected_device: ID of the infected device
            neighbors: List of neighboring device IDs

        Returns:
            List of newly infected device IDs
        """
        import random
        newly_infected = []
        
        # Check if source device has admin privileges
        source_admin = True  # Default
        if self.network:
            try:
                source_attrs = self.network.get_device_attributes(infected_device)
                source_admin = source_attrs.get('admin_user', True)
            except:
                pass  # Fall back to default if network not available
        
        for neighbor in neighbors:
            if neighbor not in self.infected_devices:
                # If source has no admin privileges, only spread to non-admin neighbors
                if not source_admin:
                    neighbor_admin = True  # Default
                    if self.network:
                        try:
                            neighbor_attrs = self.network.get_device_attributes(neighbor)
                            neighbor_admin = neighbor_attrs.get('admin_user', True)
                        except:
                            pass
                    # Can't spread to admin users from non-admin device
                    if neighbor_admin:
                        continue
                
                # Normal infection logic
                if random.random() < self.infection_rate:
                    newly_infected.append(neighbor)
        
        return newly_infected

    def get_behavior(self) -> Dict:
        """Get worm behavior characteristics."""
        return {
            "type": "worm",
            "spread_rate": "high",
            "self_replicating": True,
            "network_aware": True,
        }


class Virus(Malware):
    """Virus malware implementation."""

    def __init__(self, malware_id: str, **kwargs):
        """Initialize a virus."""
        super().__init__(malware_id, MalwareType.VIRUS, **kwargs)

    def spread(self, infected_device: str, neighbors: List[str]) -> List[str]:
        """
        Viruses spread more selectively than worms.
        
        Respects admin_user device attribute:
        - If infected_device has admin_user=False, can only spread to neighbors with admin_user=False
        - If infected_device has admin_user=True, can spread normally to all neighbors

        Args:
            infected_device: ID of the infected device
            neighbors: List of neighboring device IDs

        Returns:
            List of newly infected device IDs
        """
        import random
        newly_infected = []
        # Viruses require user interaction, so lower infection rate
        adjusted_rate = self.infection_rate * 0.6
        
        # Check if source device has admin privileges
        source_admin = True  # Default
        if self.network:
            try:
                source_attrs = self.network.get_device_attributes(infected_device)
                source_admin = source_attrs.get('admin_user', True)
            except:
                pass  # Fall back to default if network not available
        
        for neighbor in neighbors:
            if neighbor not in self.infected_devices:
                # If source has no admin privileges, only spread to non-admin neighbors
                if not source_admin:
                    neighbor_admin = True  # Default
                    if self.network:
                        try:
                            neighbor_attrs = self.network.get_device_attributes(neighbor)
                            neighbor_admin = neighbor_attrs.get('admin_user', True)
                        except:
                            pass
                    # Can't spread to admin users from non-admin device
                    if neighbor_admin:
                        continue
                
                # Normal infection logic with adjusted rate
                if random.random() < adjusted_rate:
                    newly_infected.append(neighbor)
        
        return newly_infected

    def get_behavior(self) -> Dict:
        """Get virus behavior characteristics."""
        return {
            "type": "virus",
            "spread_rate": "medium",
            "self_replicating": True,
            "requires_user_interaction": True,
        }


class Ransomware(Malware):
    """Ransomware malware implementation."""

    def __init__(self, malware_id: str, **kwargs):
        """Initialize ransomware."""
        super().__init__(malware_id, MalwareType.RANSOMWARE, **kwargs)

    def spread(self, infected_device: str, neighbors: List[str]) -> List[str]:
        """
        Ransomware spreads carefully to maximize impact.
        
        Respects admin_user device attribute:
        - If infected_device has admin_user=False, can only spread to neighbors with admin_user=False
        - If infected_device has admin_user=True, can spread normally to all neighbors

        Args:
            infected_device: ID of the infected device
            neighbors: List of neighboring device IDs

        Returns:
            List of newly infected device IDs
        """
        import random
        newly_infected = []
        # Ransomware is more selective but potentially more damaging
        adjusted_rate = self.infection_rate * 0.8
        
        # Check if source device has admin privileges
        source_admin = True  # Default
        if self.network:
            try:
                source_attrs = self.network.get_device_attributes(infected_device)
                source_admin = source_attrs.get('admin_user', True)
            except:
                pass  # Fall back to default if network not available
        
        for neighbor in neighbors:
            if neighbor not in self.infected_devices:
                # If source has no admin privileges, only spread to non-admin neighbors
                if not source_admin:
                    neighbor_admin = True  # Default
                    if self.network:
                        try:
                            neighbor_attrs = self.network.get_device_attributes(neighbor)
                            neighbor_admin = neighbor_attrs.get('admin_user', True)
                        except:
                            pass
                    # Can't spread to admin users from non-admin device
                    if neighbor_admin:
                        continue
                
                # Normal infection logic with adjusted rate
                if random.random() < adjusted_rate:
                    newly_infected.append(neighbor)
        
        return newly_infected

    def get_behavior(self) -> Dict:
        """Get ransomware behavior characteristics."""
        return {
            "type": "ransomware",
            "spread_rate": "medium-high",
            "encrypts_files": True,
            "demands_ransom": True,
        }
